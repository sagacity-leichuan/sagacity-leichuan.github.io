<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curtis Lei Blog</title>
  
  <subtitle>Computer/Software hooligan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-17T14:10:05.350Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Curtis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下C编译器和CPLUSPLUS编译器的那些事儿</title>
    <link href="http://yoursite.com/2019/05/16/Linux%E4%B8%8BC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CCPLUSPLUS%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://yoursite.com/2019/05/16/Linux下C编译器和CPLUSPLUS编译器的那些事儿/</id>
    <published>2019-05-16T14:29:06.000Z</published>
    <updated>2019-05-17T14:10:05.350Z</updated>
    
    <content type="html"><![CDATA[<p>关于gcc和g++编译器的区别和联系。<br><a id="more"></a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>&emsp;&emsp;使用C/C++编程大约有三四个年头了。最开始涉及到单片机、嵌入式Linux等，都使用的是C语言，那时主要写Linux驱动，甚至在ARM板上写Linux应用程序时需要应用面向对象的思想的时候，都是使用C语言的结构体和函数指针来实现。当然，使用的编译器自然就是gcc了。<br><br>&emsp;&emsp;后来，慢慢的转向了使用C++编写应用程序，使用C++编写的代码理所应当的就应该使用g++编译器。<br><br>&emsp;&emsp;但是，在实际的工作过程中发现，gcc和g++的使用之间却有着一些莫名的暧昧。<br><br>&emsp;&emsp;这里，要澄清几个概念：</p><hr><ul><li><code>.c</code>文件：里面可以书写纯C代码，也可以书写C++代码，二者可混合书写</li><li><code>.cpp</code>文件：里面可以书写纯C代码，也可以书写C++代码，二者可混合书写</li><li>C程序：通过gcc编译链接纯C代码的<code>.c</code>文件而得到的程序</li><li>C++程序：非C程序的C/C++程序</li><li>编译C程序：通过gcc编译链接纯C代码的.c文件获得C程序的过程</li><li>编译C++程序：可以是通过gcc编译<code>.cpp</code>文件（如果文件中无C++内容，此时仍是在编译链接一个C++程序，不需要额外指定库，反之需要），或g++编译链接<code>.c</code>、<code>.cpp</code>及其的组合获得C++程序的过程</li></ul><hr><h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>&emsp;&emsp;对于gcc编译器，首先，其默认是编译链接<code>.c</code>源文件的。但是其也可以编译链接<code>.cpp</code>源文件。详细如下：<br></p><h2 id="使用gcc处理-c源文件"><a href="#使用gcc处理-c源文件" class="headerlink" title="使用gcc处理.c源文件"></a>使用gcc处理.c源文件</h2><p>&emsp;&emsp;理所应当就是<code>.c</code>源文件里面不能有任何C++的内容。因为这种情况下gcc不会把C++相应的头文件引用进来，如果有C++的内容预处理都不会通过。即使使用<code>-I</code>选项引入头文件，那么对于C++中的关键字和符号也会识别不了。  </p><h2 id="使用gcc处理-cpp源文件"><a href="#使用gcc处理-cpp源文件" class="headerlink" title="使用gcc处理.cpp源文件"></a>使用gcc处理.cpp源文件</h2><p>&emsp;&emsp;那么gcc编译器会根据源文件后缀名为cpp，进行C++程序编译链接。在预处理，编译，汇编阶段和使用g++编译<code>.cpp</code>源文件一致，仅仅在链接阶段有所不同。因为gcc默认是使用c库链接，当源文件有使用C++的内容时，需要手动添加<code>-lstdc++</code>库。可见下面实验代码：</p><pre><code>test.cpp    #include &lt;stdio.h&gt;    void TestPrintf()    {        printf(&quot;2019-05-16\n&quot;);     }    int main(void)    {        TestPrintf();        return 0;    }</code></pre><p>&emsp;&emsp;上面是一个cpp源文件，当使用<code>gcc -o test test.cpp</code>编译时，并不会报错，因为里面没有涉及到C++的内容，是纯C特性的。但如果是下面的代码：</p><pre><code>test.cpp    #include &lt;stdio.h&gt;    #include &lt;iostream&gt;    using namespace std;    void TestPrintf()    {        printf(&quot;2019-05-16\n&quot;);        cout &lt;&lt; &quot;2019-05-16&quot; &lt;&lt; endl;     }    int main(void)    {        TestPrintf();        return 0;    }</code></pre><p>&emsp;&emsp;如果<code>.cpp</code>中有含有C++的内容，使用<code>g++ -o test test.cpp</code>编译时，会有如下打印：</p><pre><code>/tmp/ccYyDQm5.o: In function `TestPrintf()&apos;:test.cpp:(.text+0x14): undefined reference to `std::cout&apos;test.cpp:(.text+0x19): undefined reference to `std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)&apos;test.cpp:(.text+0x1e): undefined reference to `std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)&apos;test.cpp:(.text+0x26): undefined reference to `std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))&apos;/tmp/ccYyDQm5.o: In function `__static_initialization_and_destruction_0(int, int)&apos;:test.cpp:(.text+0x60): undefined reference to `std::ios_base::Init::Init()&apos;test.cpp:(.text+0x6f): undefined reference to `std::ios_base::Init::~Init()&apos;collect2: error: ld returned 1 exit status</code></pre><p>&emsp;&emsp;在进入到链接阶段的时候，便发生了链接错误。如果我们使用<code>gcc -o test test.cpp -lstdc++</code>便能编译链接成功。<br></p><h1 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h1><p>&emsp;&emsp;对于g++编译器，当他处理<code>.c</code>和<code>.cpp</code>源文件时都是<code>统一把它们当做是C++程序编译链接来处理的</code>，也就是说，此时把<code>.c</code>文件视为<code>.cpp</code>文件。二者的编译链接过程基本一致。g++在链接阶段默认是使用C++的库，这个库是完全兼容C语言的，毕竟C++是C语言的超集，在兼容C语言特性上是没有问题的。</p><h1 id="gcc同时编译-c和-cpp源文件"><a href="#gcc同时编译-c和-cpp源文件" class="headerlink" title="gcc同时编译.c和.cpp源文件"></a>gcc同时编译<code>.c</code>和<code>.cpp</code>源文件</h1><p>&emsp;&emsp;在这种情况下，在编译，汇编阶段没有错误，但是到了链接阶段，即使添加了<code>-lstdc++</code>库，也会出现链接错误。比如下面的代码：</p><pre><code>fun.h    int fun(int a, int b);</code></pre><hr><pre><code>fun.c    #include &quot;fun.h&quot;    int fun(int a, int b)    {        return a+b;    }</code></pre><hr><pre><code>text.cpp    #include &lt;iostream&gt;    #include &quot;fun.h&quot;    using namespace std;    int main(void)    {        cout &lt;&lt; fun(3,4) &lt;&lt; endl;        return 0;    }</code></pre><p>&emsp;&emsp;使用<code>gcc fun.c test.cpp -lstdc++</code>命令编译链接会出现如下的错误：</p><pre><code>/tmp/ccAdQIJn.o: In function `main&apos;:test.cpp:(.text+0xf): undefined reference to `fun(int, int)&apos;collect2: error: ld returned 1 exit status</code></pre><p>&emsp;&emsp;可见，无法找到<code>fun</code>函数，这是为什么呢？原因是gcc在处理.c文件时，在编译阶段，把<code>.cpp</code>文件用编译C程序的方式处理，对<code>.c</code>源文件中的函数和变量符号不做处理，但是在处理<code>.cpp</code>文件时，把<code>.cpp</code>文件用编译C++程序的方式处理，对源文件中出现的函数和变量符号会根据返回值和参数类型对其更改。我们执行<code>gcc -S fun.c test.cpp</code>会得到编译后的汇编文件<code>fun.s</code>和<code>test.s</code>,部分截图如下： <br><div align="center"><img src="/.com//2.png" alt="picture1"></div><div align="center">图Y</div><div align="center"><img src="/.com//3.png" alt="picture2"></div><div align="center">图X</div><br>&emsp;&emsp;由图可知，在<code>main</code>函数中，<code>call</code>指令指定的是<code>_Z3funii</code>,而在<code>fun.s</code>中的<code>fun</code>函数的汇编符号任然为<code>fun</code>，所以两个汇编文件汇编之后进入链接阶段会出现函数未定义的链接错误。此时，如果把<code>fun.c</code>的后缀名改为<code>.cpp</code>，执行<code>gcc fun.cpp test.cpp -lstdc++</code>便没有问题。</p><h1 id="g-同时编译-c和-cpp源文件"><a href="#g-同时编译-c和-cpp源文件" class="headerlink" title="g++同时编译.c和.cpp源文件"></a>g++同时编译<code>.c</code>和<code>.cpp</code>源文件</h1><p>&emsp;&emsp;完全没有问题，因为上文提到，g++编译器处理<code>.c</code>和<code>.cpp</code>源文件时都是<code>统一把它们当做是C++程序编译链接来处理的</code>。</p><h1 id="extern-quot-C-quot-和-cplusplus宏对gcc-g-的行为影响"><a href="#extern-quot-C-quot-和-cplusplus宏对gcc-g-的行为影响" class="headerlink" title="extern &quot;C&quot;和__cplusplus宏对gcc/g++的行为影响"></a><code>extern &quot;C&quot;</code>和<code>__cplusplus</code>宏对gcc/g++的行为影响</h1><p>&emsp;&emsp;在<code>.cpp</code>源文件中，由于C++支持函数<code>重载</code>，可能出现有多个同名的函数，这些函数仅仅是返回值和参数不一样，那么编译器（这里的编译器既可以是gcc也可以是g++）编译链接C++程序时会把源文件中函数的参数类型和返回值信息在编译过程输出的汇编文件中的函数符号中体现,如图X中所示，而不仅仅是函数名；但是C语言并不支持函数<code>重载</code>，因此编译链接C程序时对源代码的函数在编译汇编过程中不会带上函数的参数类型等信息，一般只包括函数名，如图Y所示。<br>&emsp;&emsp;<code>extern &quot;C&quot;</code>的主要作用就是为了能够正确实现C++代码调用其他C语言代码。比如，在C++程序中调用使用.c源文件编写的同时使用gcc编译出来库的时候，在编译链接这个C++程序过程中，引用的头文件中函数声明的地方加上<code>extern &quot;C&quot;</code>后，会指示编译器在编译C++程序时这部分代码按编译C程序（而不是C++程序）的方式进行编译。如下所示：</p><pre><code>fun.h    extern &quot;C&quot;    {        int fun(int a, int b);    }</code></pre><p>&emsp;&emsp;如果一个函数使用这样的方式声明的话，在编译链接C++源文件（这里的C++源文件可以是<code>.cpp</code>文件或有C++内容的.c文件，只是这里的<code>.c</code>文件需要使用g++编译链接，<code>.cpp</code>文件可以使用gcc和g++编译链接）中，编译的时候就不会对这个函数相关的代码做C++程序的处理，而是用C程序的方式处理。<br><br>&emsp;&emsp;在编译C++程序时，会有<code>__cplusplus</code>宏存在，而编译C程序时没有，与使用gcc和g++无关，毕竟gcc也可以编译一个C++程序。<br><br>&emsp;&emsp;下面我们使用一些实验来说明：<br><br>&emsp;&emsp;对于如下下代码：</p><pre><code>test.c    #include &lt;stdio.h&gt;    void TestPrintf()    {        printf(&quot;2019-05-16\n&quot;);     }    int main(void)    {        TestPrintf();        return 0;    }</code></pre><ul><li><p>gcc编译<code>.c</code>时，这就是纯C编译，没有问题。如果对上面的代码执行<code>gcc -S test.c</code>生成的test.s文件中函数名称<code>TestPrintf</code>没有改变。如图：<br><div align="center"><img src="/.com//1.png" alt="picture0"></div><div align="center">图Q</div></p></li><li><p>如果使用g++编译<code>.c</code>源文件，.c源文件会当做C++程序编译。如果对上面的代码执行<code>g++ -S test.c</code>生成的test.s文件中函数名称<code>TestPrintf</code>发生改变。如图：<br><div align="center"><img src="/.com//4.png" alt="picture3"></div><div align="center">图P</div>但是如果在<code>test.c</code>改为如下，这效果和执行<code>gcc -S test.c</code>一样。</p></li></ul><hr><pre><code>test.c    #include &lt;stdio.h&gt;    #include &quot;fun.h&quot;    extern &quot;C&quot;    {        void TestPrintf();    }    void TestPrintf()    {        printf(&quot;%d\n&quot;, fun(4,5));    }    int main(void)    {        TestPrintf();        return 0;    }</code></pre><hr><p>对于如下代码：</p><pre><code>test.cpp    #include &lt;stdio.h&gt;    void TestPrintf()    {        printf(&quot;2019-05-16\n&quot;);     }    int main(void)    {        TestPrintf();        return 0;    }</code></pre><ul><li>gcc和g++编译<code>test.cpp</code>文件时，都是在编译一个C++程序，都会对.cpp源文件中的函数和变量符号做变更处理。这时，如果一个函数在声明时使用<code>extern &quot;C&quot;</code>，如下面代码所示，那么就会用编译C程序的方式处理与这个函数相关的代码。</li></ul><hr><pre><code>test.cpp    #include &lt;stdio.h&gt;    extern &quot;C&quot;    {        void TestPrintf()    }    void TestPrintf()    {        printf(&quot;2019-05-16\n&quot;);     }    int main(void)    {        TestPrintf();        return 0;    }</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gcc在处理<code>.c</code>文件时，把这个过程作为编译链接一个C程序的过程</li><li>gcc在处理<code>.cpp</code>文件时，把这个过程作为编译链接一个C++程序的过程，但是gcc默认在链接阶段使用C库，如果<code>.cpp</code>文件中涉及到使用C++库，则需要手动指定库</li><li>gcc既可以编译一个C程序，也可以编译一个C++程序</li><li>g++在处理<code>.c</code>文件时，把其看做是一个.cpp文件处理，且其编译链接后的只能是C++程序，而gcc仅仅在处理<code>.cpp</code>文件时，编译链接之后产生的才是C++程序</li><li>在编译链接C++程序中存在<code>__cplusplus</code>宏，在编译链接C程序时不存在，与使用gcc还是g++编译器无关，可以使用此宏做预编译条件判断。</li></ul><hr><div align="center"><br><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><br>    <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"><br></a><br><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可，欢迎转载，但转载请注明来自Curtis Lei Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于gcc和g++编译器的区别和联系。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux系统" scheme="http://yoursite.com/tags/linux%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="编译器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于libevent的简易HTTP服务器实现(访问静态文件、下载文件等)</title>
    <link href="http://yoursite.com/2019/05/15/%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84%E7%AE%80%E6%98%93HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0-%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%AD%89/"/>
    <id>http://yoursite.com/2019/05/15/基于libevent的简易HTTP服务器实现-访问静态文件、下载文件等/</id>
    <published>2019-05-14T16:56:50.000Z</published>
    <updated>2019-05-16T14:36:19.664Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
      <category term="CPlusPlus" scheme="http://yoursite.com/tags/CPlusPlus/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="CPlusPlus应用软件" scheme="http://yoursite.com/tags/CPlusPlus%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>基于libevent的通用线程池实现</title>
    <link href="http://yoursite.com/2019/05/15/%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84%E9%80%9A%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/15/基于libevent的通用线程池实现/</id>
    <published>2019-05-14T16:31:00.000Z</published>
    <updated>2019-05-16T14:35:51.931Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
      <category term="CPlusPlus" scheme="http://yoursite.com/tags/CPlusPlus/"/>
    
      <category term="CPlusPlus应用软件" scheme="http://yoursite.com/tags/CPlusPlus%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="事件通知" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
